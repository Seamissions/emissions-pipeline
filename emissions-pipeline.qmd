---
title: "Emissions Pipeline"
date: last-modified
format:
  html:
      toc: true
      code-fold: true
editor: visual
execute:
  warning: false
  messages: false
editor_options: 
  chunk_output_type: console
---

# About

This repository hosts the code to create the open source data processing pipeline.

## Load packages

```{r}
#| code-summary: Expand code
library(tidyverse)
library(janitor)
library(here)
library(gghighlight)
library(lubridate)
```

## Load data

```{r}
#| code-summary: Expand code

# Turn off scientific notation
options(scipen=999)

# Set file path to data folder
pathway <- "/capstone/seamissions/data/meds_capstone_project"

# Set up import for .csv or .xlsx files
file_names <- list.files(here(pathway), pattern=paste0(c("*.xlsx","*.csv"), collapse="|"), full.names=TRUE)

# Read in data files
for (i in seq_along(file_names)) {
  # If .csv, read_csv
  if(grepl('.*\\.csv', file_names[i])) {
        table <- read_csv(file_names[i], show_col_types = FALSE) %>%
          clean_names()
         } else {
           # If .xslx, read_excel
           table <- read_excel(file_names[i]) %>%
             clean_names()
         }
  
  # Rename files truncated names
  if(str_detect(file_names[i], "non")) {
    table_name <- substr(file_names[i], 64, 79)
  } else {
    table_name <- substr(file_names[i], 64, 76)
  }
  assign(table_name, table)
}
```

## Clean data

```{r}
#| code-summary: Expand code
# Create `year_month` column
broadcasting <- ais_emissions %>%
  mutate(date = lubridate::ymd(month)) %>%
  mutate(year_month = format(date, '%Y-%m'))
  
# Create `year_month` column
non_broadcasting <- non_broadcasting %>%
  mutate(date = lubridate::ymd(month)) %>%
  mutate(year_month = format(date, '%Y-%m'))
```

```{r}
#| code-summary: Expand code

#  ---- Left join broadcasting and non-broadcasting datasets ----
emissions <- left_join(broadcasting, non_broadcasting, by = c("year_month", "lat_bin", "lon_bin", "length_size_class_percentile")) %>%
  
  # Select columns to keep
  select(year_month, 
         lon_bin,
         lat_bin,
         flag, 
         vessel_class, 
         length_size_class_percentile, 
         fishing_activity, 
         hours, 
         kw_hours,
         emissions_co2_mt, 
         emissions_ch4_mt, 
         emissions_n2o_mt, 
         emissions_nox_mt, 
         emissions_sox_mt, 
         emissions_pm_mt, 
         emissions_co_mt,
         emissions_co2_non_broadcasting_mt,
         emissions_ch4_non_broadcasting_mt,
         emissions_n2o_non_broadcasting_mt,
         emissions_nox_non_broadcasting_mt,
         emissions_sox_non_broadcasting_mt,
         emissions_pm_non_broadcasting_mt,
         emissions_co_non_broadcasting_mt)

# Subset data to 2017 for test
emissions_2017_11 <- emissions %>%
  filter(year_month == "2017-11")

# ---- Partition emissions for test data ----

key <- emissions_2017_11 %>%
  # Calculate total kw hours per grouped "ship"
  group_by(year_month, lon_bin, lat_bin, flag, vessel_class, length_size_class_percentile, hours, kw_hours) %>% # `hours` and `kw_hours`?
  mutate(kw_hours_by_ship = sum(kw_hours, na.rm = TRUE)) %>%
  
  # Calculate total `kw_hours` per pixel 
  group_by(year_month, lon_bin, lat_bin) %>%
  mutate(total_kw_hours = sum(kw_hours, na.rm = TRUE)) %>%
  ungroup() %>%
  
  # Define a factor for the proportion of hours per flag/total hours 
  mutate(factor = kw_hours_by_ship/total_kw_hours) %>%
  
  # Apply factor to emissions columns to partition nb data
  mutate(total_co2 = emissions_co2_mt + (factor * emissions_co2_non_broadcasting_mt),
         total_ch4 = emissions_ch4_mt + (factor * emissions_ch4_non_broadcasting_mt),
         total_n2o = emissions_n2o_mt + (factor * emissions_n2o_non_broadcasting_mt),
         total_nox = emissions_nox_mt + (factor * emissions_nox_non_broadcasting_mt),
         total_sox = emissions_sox_mt + (factor * emissions_sox_non_broadcasting_mt),
         total_pm = emissions_pm_mt + (factor * emissions_pm_non_broadcasting_mt),
         total_co = emissions_co_mt + (factor * emissions_co_non_broadcasting_mt)) %>%

    # Select columns of interest
   select(year_month, 
         lon_bin,
         lat_bin,
         flag, 
         vessel_class, 
         length_size_class_percentile, 
         fishing_activity, 
         hours, 
         kw_hours,
         total_co2, 
         total_ch4, 
         total_n2o, 
         total_nox, 
         total_sox, 
         total_pm, 
         total_co)

# Adapt this code to full dataset
```

So, in theory, the sum of the co2 from the broadcasting dataset (filtered for 2017-11) and the sum of the co2 from the non_broadcasting dataset (filtered for 2017-11) should equal the sum of the co2 from the processed dataset (key).

We didn't use the sum of the co2 columns in the emissions_2017_11 dataset because non-broadcasting co2 is printed multiple times for each pixel.
```{r}
# Check to see that all pixel `factor` sum to 1
test <- key %>%
  group_by(year_month, lon_bin, lat_bin) %>%
  summarise(sum = sum(factor))

# Only 1s
unique(test$sum)
max(test$sum)
min(test$sum)

# Sum of broadcasting co2
broad_emissions <- broadcasting %>%
  filter(year_month == "2017-11") %>%
  summarise(emissions = sum(emissions_co2_mt, na.rm = TRUE))

non_broad_emissions <- non_broadcasting %>%
  filter(year_month == "2017-11") %>%
  summarise(emissions = sum(emissions_co2_non_broadcasting_mt, na.rm =TRUE))

emissions_total <- broad_emissions[1] + non_broad_emissions[1]
emissions_total_factored <- sum(key$total_co2, na.rm = TRUE)

diff <- emissions_total_factored - emissions_total
```

## Decision points:

-   If only dark fleet in a pixel, how do we distribute emissions? Next closest month or next closest pixel? - add +/-1 to lat_long?

## Visualize (maps, time series plots)



- group by `hours` *and* `kw_hours`?
